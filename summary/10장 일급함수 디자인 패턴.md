GoFì˜ ë””ìì¸ íŒ¨í„´ìœ¼ë¡œ ë””ìì¸ íŒ¨í„´ì€ ì¸ê¸°ë¥¼ ì–»ìŒ. ë””ìì¸ íŒ¨í„´ì´ ì–¸ì–´ì— ë…ë¦½ì ì´ê¸°ëŠ” í•˜ì§€ë§Œ, ê·¸ë ‡ë‹¤ê³  í•´ì„œ ëª¨ë“  ì–¸ì–´ì— ì ìš©í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë‹˜. íŒŒì´ì¬ìœ¼ë¡œ [ë°˜ë³µì íŒ¨í„´](https://en.wikipedia.org/wiki/Iterator_pattern) ë ˆì‹œí”¼ë¥¼ í‰ë‚´ë‚´ëŠ” ê²ƒì´ ì˜ë¯¸ê°€ ì—†ìŒì„ ë³´ì—¬ì¤Œ. í•´ë‹¹ íŒ¨í„´ì´ ì–¸ì–´ì— í¬í•¨ ë˜ì–´ìˆê³  ì œë„ˆë ˆì´í„° í˜•íƒœë¡œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸.

[ë™ì  ì–¸ì–´ì—ì„œì˜ ë””ìì¸ íŒ¨í„´ ë°œí‘œ](https://norvig.com/design-patterns/) GoFì˜ íŒ¨í„´ ì¤‘ 16ê°œëŠ” ë™ì  ì–¸ì–´ì—ì„œ ë³´ì´ì§€ ì•Šê±°ë‚˜ ë” ë‹¨ìˆœí•¨.

íŠ¹íˆ ì¼ê¸‰ í•¨ìˆ˜ë¥¼ ì§€ì›í•˜ëŠ” ì–¸ì–´ì—ì„œëŠ” ì „ëµ, ëª…ë ¹, í…œí”Œë¦¿ ë©”ì„œë“œ, ë¹„ì§€í„° íŒ¨í„´ì„ ë‹¤ì‹œ ìƒê°í•´ë³´ë¼ê³  ê¶Œê³ 

(ì „ìì±…ì´ ì•„ë‹ˆë‹ˆ ë¶ˆí¸í•˜ë„¤.. ê·¸ êµ¬ë§¤ â†’ í• ì¸ ì˜ˆì‹œë¥¼ ìƒê°í•´ë³´ì. )

ì „ëµ ê°ì²´ëŠ” ì¢…ì¢… í›Œë¥­í•­ í”Œë¼ì— ì›¨ì´íŠ¸ê°€ ë¨. í”Œë¼ì´ ì›¨ì´íŠ¸ == ì—¬ëŸ¬ ì½˜í…ìŠ¤íŠ¸ì—ì„œ ë™ì‹œì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê³µìœ  ê°ì²´

- ê³ ì „ì ì¸ ë°©ì‹

    ```python
    # classic_strategy.py
    # Strategy pattern -- classic implementation
    
    """
    # tag::CLASSIC_STRATEGY_TESTS[]
    
        >>> joe = Customer('John Doe', 0)  # <1>
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = (LineItem('banana', 4, Decimal('.5')),  # <2>
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5)))
        >>> Order(joe, cart, FidelityPromo())  # <3>
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, FidelityPromo())  # <4>
        <Order total: 42.00 due: 39.90>
        >>> banana_cart = (LineItem('banana', 30, Decimal('.5')),  # <5>
        ...                LineItem('apple', 10, Decimal('1.5')))
        >>> Order(joe, banana_cart, BulkItemPromo())  # <6>
        <Order total: 30.00 due: 28.50>
        >>> long_cart = tuple(LineItem(str(sku), 1, Decimal(1)) # <7>
        ...                  for sku in range(10))
        >>> Order(joe, long_cart, LargeOrderPromo())  # <8>
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, LargeOrderPromo())
        <Order total: 42.00 due: 42.00>
    
    # end::CLASSIC_STRATEGY_TESTS[]
    """
    # tag::CLASSIC_STRATEGY[]
    
    from abc import ABC, abstractmethod
    from collections.abc import Sequence
    from decimal import Decimal
    from typing import NamedTuple, Optional
    
    class Customer(NamedTuple):
        name: str
        fidelity: int
    
    class LineItem(NamedTuple):
        product: str
        quantity: int
        price: Decimal
    
        def total(self) -> Decimal:
            return self.price * self.quantity
    
    class Order(NamedTuple):  # the Context
        customer: Customer
        cart: Sequence[LineItem]
        promotion: Optional['Promotion'] = None
    
        def total(self) -> Decimal:
            totals = (item.total() for item in self.cart)
            return sum(totals, start=Decimal(0))
    
        def due(self) -> Decimal:
            if self.promotion is None:
                discount = Decimal(0)
            else:
                discount = self.promotion.discount(self)
            return self.total() - discount
    
        def __repr__(self):
            return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'
    
    class Promotion(ABC):  # the Strategy: an abstract base class
        @abstractmethod
        def discount(self, order: Order) -> Decimal:
            """Return discount as a positive dollar amount"""
    
    class FidelityPromo(Promotion):  # first Concrete Strategy
        """5% discount for customers with 1000 or more fidelity points"""
    
        def discount(self, order: Order) -> Decimal:
            rate = Decimal('0.05')
            if order.customer.fidelity >= 1000:
                return order.total() * rate
            return Decimal(0)
    
    class BulkItemPromo(Promotion):  # second Concrete Strategy
        """10% discount for each LineItem with 20 or more units"""
    
        def discount(self, order: Order) -> Decimal:
            discount = Decimal(0)
            for item in order.cart:
                if item.quantity >= 20:
                    discount += item.total() * Decimal('0.1')
            return discount
    
    class LargeOrderPromo(Promotion):  # third Concrete Strategy
        """7% discount for orders with 10 or more distinct items"""
    
        def discount(self, order: Order) -> Decimal:
            distinct_items = {item.product for item in order.cart}
            if len(distinct_items) >= 10:
                return order.total() * Decimal('0.07')
            return Decimal(0)
    # end::CLASSIC_STRATEGY[]
    ```

- í•¨ìˆ˜ë¡œ ëŒ€ì²´ (classê°€ ì•„ë‹ˆë¼ í•¨ìˆ˜ë¡œ í•´ì„œ ì½”ë“œì–‘ì´ ì ìŒ. ê° ì£¼ë¬¸ì— ëŒ€í•´ í• ì¸ ê°ì²´ë¥¼ ìƒˆë¡œ ë§Œë“¤ í•„ìš” ì—†ìŒ)

    ```python
    # strategy.py
    # Strategy pattern -- function-based implementation
    
    """
    # tag::STRATEGY_TESTS[]
    
        >>> joe = Customer('John Doe', 0)  # <1>
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, Decimal('.5')),
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5))]
        >>> Order(joe, cart, fidelity_promo)  # <2>
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, fidelity_promo)
        <Order total: 42.00 due: 39.90>
        >>> banana_cart = [LineItem('banana', 30, Decimal('.5')),
        ...                LineItem('apple', 10, Decimal('1.5'))]
        >>> Order(joe, banana_cart, bulk_item_promo)  # <3>
        <Order total: 30.00 due: 28.50>
        >>> long_cart = [LineItem(str(item_code), 1, Decimal(1))
        ...               for item_code in range(10)]
        >>> Order(joe, long_cart, large_order_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, large_order_promo)
        <Order total: 42.00 due: 42.00>
    
    # end::STRATEGY_TESTS[]
    """
    # tag::STRATEGY[]
    
    from collections.abc import Sequence
    from dataclasses import dataclass
    from decimal import Decimal
    from typing import Optional, Callable, NamedTuple
    
    class Customer(NamedTuple):
        name: str
        fidelity: int
    
    class LineItem(NamedTuple):
        product: str
        quantity: int
        price: Decimal
    
        def total(self):
            return self.price * self.quantity
    
    @dataclass(frozen=True)
    class Order:  # the Context
        customer: Customer
        cart: Sequence[LineItem]
        promotion: Optional[Callable[['Order'], Decimal]] = None  # <1>
    
        def total(self) -> Decimal:
            totals = (item.total() for item in self.cart)
            return sum(totals, start=Decimal(0))
    
        def due(self) -> Decimal:
            if self.promotion is None:
                discount = Decimal(0)
            else:
                discount = self.promotion(self)  # <2>
            return self.total() - discount
    
        def __repr__(self):
            return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'
    
    # <3>
    
    def fidelity_promo(order: Order) -> Decimal:  # <4>
        """5% discount for customers with 1000 or more fidelity points"""
        if order.customer.fidelity >= 1000:
            return order.total() * Decimal('0.05')
        return Decimal(0)
    
    def bulk_item_promo(order: Order) -> Decimal:
        """10% discount for each LineItem with 20 or more units"""
        discount = Decimal(0)
        for item in order.cart:
            if item.quantity >= 20:
                discount += item.total() * Decimal('0.1')
        return discount
    
    def large_order_promo(order: Order) -> Decimal:
        """7% discount for orders with 10 or more distinct items"""
        distinct_items = {item.product for item in order.cart}
        if len(distinct_items) >= 10:
            return order.total() * Decimal('0.07')
        return Decimal(0)
    
    # end::STRATEGY[]
    ```


ìµœì ì˜ í• ì¸ë¥  ì ìš©ì„ í•´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ë¦¬íŒ©í† ë§

- ë‹¨ìˆœí•œ ë°©ë²• ( ëª¨ë“  í•¨ìˆ˜ ë‹¤ ëŒë¦¼, ìƒˆë¡œìš´ í• ì¸ ì „ëµ ì¶”ê°€í•˜ë ¤ë©´ í•¨ìˆ˜ë¥¼ ì½”ë”©í•˜ê³  ì´ í•¨ìˆ˜ë¥¼ promos ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•´ì•¼í•¨)

    ```python
    # strategy_best.py
    # Strategy pattern -- function-based implementation
    # selecting best promotion from static list of functions
    
    """
        >>> from strategy import Customer, LineItem
        >>> joe = Customer('John Doe', 0)
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, Decimal('.5')),
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5))]
        >>> banana_cart = [LineItem('banana', 30, Decimal('.5')),
        ...                LineItem('apple', 10, Decimal('1.5'))]
        >>> long_cart = [LineItem(str(item_code), 1, Decimal(1))
        ...               for item_code in range(10)]
    
    # tag::STRATEGY_BEST_TESTS[]
    
        >>> Order(joe, long_cart, best_promo)  # <1>
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, banana_cart, best_promo)  # <2>
        <Order total: 30.00 due: 28.50>
        >>> Order(ann, cart, best_promo)  # <3>
        <Order total: 42.00 due: 39.90>
    
    # end::STRATEGY_BEST_TESTS[]
    """
    
    from decimal import Decimal
    
    from strategy import Order
    from strategy import fidelity_promo, bulk_item_promo, large_order_promo
    
    # tag::STRATEGY_BEST[]
    
    promos = [fidelity_promo, bulk_item_promo, large_order_promo]  # <1>
    
    def best_promo(order: Order) -> Decimal:  # <2>
        """Compute the best discount available"""
        return max(promo(order) for promo in promos)  # <3>
    
    # end::STRATEGY_BEST[]
    ```

- ëª¨ë“ˆì—ì„œ ì „ëµ ì°¾ê¸° (promotionsì„ ì •ì˜í•œ ëª¨ë“ˆì„ import í•œ ë‹¤ìŒ inspectë¡œ ê°€ì ¸ì˜¤ëŠ” ë°©ì‹ or globalì—ì„œ _promoë¡œ ëë‚˜ëŠ” ê²ƒì„ ëª¨ë‘ ì°¾ì•„ì„œ ì¶”ê°€)

    ```python
    #inspect í™œìš©
    
    # strategy_best3.py
    # Strategy pattern -- function-based implementation
    # selecting best promotion from imported module
    
    """
        >>> from decimal import Decimal
        >>> from strategy import Customer, LineItem, Order
        >>> from promotions import *
        >>> joe = Customer('John Doe', 0)
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, Decimal('.5')),
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5))]
        >>> Order(joe, cart, fidelity_promo)
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, fidelity_promo)
        <Order total: 42.00 due: 39.90>
        >>> banana_cart = [LineItem('banana', 30, Decimal('.5')),
        ...                LineItem('apple', 10, Decimal('1.5'))]
        >>> Order(joe, banana_cart, bulk_item_promo)
        <Order total: 30.00 due: 28.50>
        >>> long_cart = [LineItem(str(item_code), 1, Decimal(1))
        ...               for item_code in range(10)]
        >>> Order(joe, long_cart, large_order_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, large_order_promo)
        <Order total: 42.00 due: 42.00>
    
    # tag::STRATEGY_BEST_TESTS[]
    
        >>> Order(joe, long_cart, best_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, banana_cart, best_promo)
        <Order total: 30.00 due: 28.50>
        >>> Order(ann, cart, best_promo)
        <Order total: 42.00 due: 39.90>
    
    # end::STRATEGY_BEST_TESTS[]
    """
    
    # tag::STRATEGY_BEST3[]
    
    from decimal import Decimal
    import inspect
    
    from strategy import Order
    import promotions
    
    promos = [func for _, func in inspect.getmembers(promotions, inspect.isfunction)]
    
    def best_promo(order: Order) -> Decimal:
        """Compute the best discount available"""
        return max(promo(order) for promo in promos)
    
    # end::STRATEGY_BEST3[]
    ```

    ```python
    # global í™œìš©
    
    # strategy_best2.py
    # Strategy pattern -- function-based implementation
    # selecting best promotion from current module globals
    
    """
        >>> from decimal import Decimal
        >>> from strategy import Customer, LineItem, Order
        >>> joe = Customer('John Doe', 0)
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, Decimal('.5')),
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5))]
        >>> Order(joe, cart, fidelity_promo)
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, fidelity_promo)
        <Order total: 42.00 due: 39.90>
        >>> banana_cart = [LineItem('banana', 30, Decimal('.5')),
        ...                LineItem('apple', 10, Decimal('1.5'))]
        >>> Order(joe, banana_cart, bulk_item_promo)
        <Order total: 30.00 due: 28.50>
        >>> long_cart = [LineItem(str(item_code), 1, Decimal(1))
        ...               for item_code in range(10)]
        >>> Order(joe, long_cart, large_order_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, large_order_promo)
        <Order total: 42.00 due: 42.00>
    
    # tag::STRATEGY_BEST_TESTS[]
    
        >>> Order(joe, long_cart, best_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, banana_cart, best_promo)
        <Order total: 30.00 due: 28.50>
        >>> Order(ann, cart, best_promo)
        <Order total: 42.00 due: 39.90>
    
    # end::STRATEGY_BEST_TESTS[]
    """
    
    # tag::STRATEGY_BEST2[]
    from decimal import Decimal
    from strategy import Order
    from strategy import (
        fidelity_promo, bulk_item_promo, large_order_promo  # <1>
    )
    
    promos = [promo for name, promo in globals().items()  # <2>
                    if name.endswith('_promo') and        # <3>
                       name != 'best_promo'               # <4>
    ]
    
    def best_promo(order: Order) -> Decimal:              # <5>
        """Compute the best discount available"""
        return max(promo(order) for promo in promos)
    
    # end::STRATEGY_BEST2[]
    ```

- ë°ì»¤ë ˆì´í„°ë¡œ ê°œì„ í•œ ì „ëµ íŒ¨í„´ (sideimpact consoleì—ì„œ ë‚´ê°€ í•œ ê²ƒê³¼ ë¹„ìŠ·. ë°ì»¤ë ˆì´í„°ë¡œ listì— ê·¸ëƒ¥ ë“±ë¡í•´ë²„ë¦¼)

    ```python
    # strategy_best4.py
    # Strategy pattern -- function-based implementation
    # selecting best promotion from list of functions
    # registered by a decorator
    
    """
        >>> from decimal import Decimal
        >>> from strategy import Customer, LineItem, Order
        >>> from promotions import *
        >>> joe = Customer('John Doe', 0)
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, Decimal('.5')),
        ...         LineItem('apple', 10, Decimal('1.5')),
        ...         LineItem('watermelon', 5, Decimal(5))]
        >>> Order(joe, cart, fidelity_promo)
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, fidelity_promo)
        <Order total: 42.00 due: 39.90>
        >>> banana_cart = [LineItem('banana', 30, Decimal('.5')),
        ...                LineItem('apple', 10, Decimal('1.5'))]
        >>> Order(joe, banana_cart, bulk_item_promo)
        <Order total: 30.00 due: 28.50>
        >>> long_cart = [LineItem(str(item_code), 1, Decimal(1))
        ...               for item_code in range(10)]
        >>> Order(joe, long_cart, large_order_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, large_order_promo)
        <Order total: 42.00 due: 42.00>
    
    # tag::STRATEGY_BEST_TESTS[]
    
        >>> Order(joe, long_cart, best_promo)
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, banana_cart, best_promo)
        <Order total: 30.00 due: 28.50>
        >>> Order(ann, cart, best_promo)
        <Order total: 42.00 due: 39.90>
    
    # end::STRATEGY_BEST_TESTS[]
    """
    
    from decimal import Decimal
    from typing import Callable
    
    from strategy import Order
    
    # tag::STRATEGY_BEST4[]
    
    Promotion = Callable[[Order], Decimal]
    
    promos: list[Promotion] = []  # <1>
    
    def promotion(promo: Promotion) -> Promotion:  # <2>
        promos.append(promo)
        return promo
    
    def best_promo(order: Order) -> Decimal:
        """Compute the best discount available"""
        return max(promo(order) for promo in promos)  # <3>
    
    @promotion  # <4>
    def fidelity(order: Order) -> Decimal:
        """5% discount for customers with 1000 or more fidelity points"""
        if order.customer.fidelity >= 1000:
            return order.total() * Decimal('0.05')
        return Decimal(0)
    
    @promotion
    def bulk_item(order: Order) -> Decimal:
        """10% discount for each LineItem with 20 or more units"""
        discount = Decimal(0)
        for item in order.cart:
            if item.quantity >= 20:
                discount += item.total() * Decimal('0.1')
        return discount
    
    @promotion
    def large_order(order: Order) -> Decimal:
        """7% discount for orders with 10 or more distinct items"""
        distinct_items = {item.product for item in order.cart}
        if len(distinct_items) >= 10:
            return order.total() * Decimal('0.07')
        return Decimal(0)
    
    # end::STRATEGY_BEST4[]
    ```


### ëª…ë ¹ íŒ¨í„´ â†’ ê³µë¶€ ë” í•„ìš”â€¦

ëª…ë ¹ íŒ¨í„´ì˜ ëª©ì ì€ ì—°ì‚°ì„ ì‹¤í–‰í•˜ëŠ” ê°ì²´(í˜¸ì¶œì invoker)ì™€ ì—°ì‚°ì„ êµ¬í˜„í•˜ëŠ” ê°ì²´ (ìˆ˜ì‹ ì receiver)ë¥¼ ë¶„ë¦¬í•˜ëŠ” ê²ƒ.

- GPTì˜ ì˜ˆì‹œ ( __call__ ì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ë²„ì „)

  ëª…ë ¹ íŒ¨í„´(Command Pattern)ì€ **ìš”ì²­ì„ ê°ì²´ë¡œ ìº¡ìŠí™”í•˜ì—¬ í˜¸ì¶œì(Invoker)ì™€ ìˆ˜ì‹ ì(Receiver)ë¥¼ ë¶„ë¦¬í•˜ëŠ” ë””ìì¸ íŒ¨í„´**ì…ë‹ˆë‹¤.

  ì´ì œ **ë‹¤ì´ì–´ê·¸ë¨ê³¼ ì½”ë“œ ì˜ˆì œ**ë¥¼ í†µí•´ ìƒì„¸íˆ ì„¤ëª…í•´ë³´ê² ìŠµë‹ˆë‹¤. ğŸš€

  **âœ… ëª…ë ¹ íŒ¨í„´ (Command Pattern) ê°œë…**

  **ğŸ¯ ëª©ì **

    1.	**í˜¸ì¶œì(Invoker)ì™€ ìˆ˜ì‹ ì(Receiver)ë¥¼ ë¶„ë¦¬**í•˜ì—¬ **ìœ ì—°í•œ ì„¤ê³„**ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•¨.

    2.	**ìš”ì²­ì„ ìº¡ìŠí™”**í•˜ì—¬ ì‹¤í–‰ ì·¨ì†Œ(Undo), ì¬ì‹¤í–‰(Redo), ì‘ì—… í ë“±ì„ ì‰½ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆìŒ.

    3.	**ê°ì²´ ì§€í–¥ì ì¸ ë°©ë²•ìœ¼ë¡œ ê¸°ëŠ¥ì„ í™•ì¥**í•  ìˆ˜ ìˆìŒ.

  **âœ… ëª…ë ¹ íŒ¨í„´ UML ë‹¤ì´ì–´ê·¸ë¨**

  ì•„ë˜ëŠ” ëª…ë ¹ íŒ¨í„´ì˜ **êµ¬ì„± ìš”ì†Œ**ë¥¼ ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ í‘œí˜„í•œ ê²ƒì…ë‹ˆë‹¤.

    ```
    +------------------+        +------------------+        +------------------+
    |  Invoker        |        | Command          |        | Receiver         |
    |-----------------|        |-----------------|        |-----------------|
    | - command: Command |        | + execute()    |        | + action()      |
    | + set_command(c) |<-------|-----------------|        |                 |
    | + execute_command()|----->| (ConcreteCommand) |----->| (ConcreteReceiver)|
    +------------------+        +------------------+        +------------------+
    ```

  **ğŸ” êµ¬ì„± ìš”ì†Œ**

  | **êµ¬ì„± ìš”ì†Œ** | **ì—­í• ** |
      | --- | --- |
  | Invoker (í˜¸ì¶œì) | ëª…ë ¹ì„ ì‹¤í–‰í•˜ëŠ” ê°ì²´ (ex. ë²„íŠ¼, ë¦¬ëª¨ì»¨) |
  | Command (ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤) | ëª¨ë“  ëª…ë ¹ í´ë˜ìŠ¤ê°€ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ |
  | ConcreteCommand (êµ¬ì²´ì ì¸ ëª…ë ¹) | íŠ¹ì • ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ëª…ë ¹ (ex. TV ì¼œê¸°, ë„ê¸°) |
  | Receiver (ìˆ˜ì‹ ì) | ì‹¤ì œ ë™ì‘ì„ ìˆ˜í–‰í•˜ëŠ” ê°ì²´ (ex. TV, ì¡°ëª… ë“±) |

  **âœ… Python ì½”ë“œ ì˜ˆì œ**

  ì•„ë˜ëŠ” **TVì˜ ì¼œê¸°/ë„ê¸° ê¸°ëŠ¥ì„ ëª…ë ¹ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•œ ì˜ˆì œ**ì…ë‹ˆë‹¤.

    ```
    # 1. Command ì¸í„°í˜ì´ìŠ¤ ì •ì˜
    from abc import ABC, abstractmethod
    
    class Command(ABC):
        @abstractmethod
        def execute(self):
            pass
    
    # 2. Receiver (ì‹¤ì œ ë™ì‘ì„ ìˆ˜í–‰í•˜ëŠ” ê°ì²´)
    class TV:
        def turn_on(self):
            print("TVë¥¼ ì¼­ë‹ˆë‹¤.")
    
        def turn_off(self):
            print("TVë¥¼ ë•ë‹ˆë‹¤.")
    
    # 3. ConcreteCommand (êµ¬ì²´ì ì¸ ëª…ë ¹)
    class TVOnCommand(Command):
        def __init__(self, tv: TV):
            self.tv = tv
    
        def execute(self):
            self.tv.turn_on()
    
    class TVOffCommand(Command):
        def __init__(self, tv: TV):
            self.tv = tv
    
        def execute(self):
            self.tv.turn_off()
    
    # 4. Invoker (í˜¸ì¶œì)
    class RemoteControl:
        def __init__(self):
            self.command = None  # ì‹¤í–‰í•  ëª…ë ¹ ì €ì¥
    
        def set_command(self, command: Command):
            self.command = command
    
        def press_button(self):
            if self.command:
                self.command.execute()
    
    # ì‹¤í–‰ í…ŒìŠ¤íŠ¸
    tv = TV()
    remote = RemoteControl()
    
    # TV ì¼œê¸° ëª…ë ¹ì„ ì„¤ì •í•˜ê³  ì‹¤í–‰
    on_command = TVOnCommand(tv)
    remote.set_command(on_command)
    remote.press_button()  # TVë¥¼ ì¼­ë‹ˆë‹¤.
    
    # TV ë„ê¸° ëª…ë ¹ì„ ì„¤ì •í•˜ê³  ì‹¤í–‰
    off_command = TVOffCommand(tv)
    remote.set_command(off_command)
    remote.press_button()  # TVë¥¼ ë•ë‹ˆë‹¤.
    ```

  **âœ… ì‹¤í–‰ ê²°ê³¼**

    ```
    TVë¥¼ ì¼­ë‹ˆë‹¤.
    TVë¥¼ ë•ë‹ˆë‹¤.
    ```

  **âœ… ì½”ë“œ ë¶„ì„**

    1.	Command (ì¸í„°í˜ì´ìŠ¤): ëª¨ë“  ëª…ë ¹ í´ë˜ìŠ¤ê°€ êµ¬í˜„í•´ì•¼ í•˜ëŠ” **ì¶”ìƒ í´ë˜ìŠ¤**.

    2.	TV (Receiver): **ì‹¤ì œ ë™ì‘ì„ ìˆ˜í–‰í•˜ëŠ” ê°ì²´**.

    3.	TVOnCommand / TVOffCommand (ConcreteCommand): **TVì˜ ì¼œê¸°/ë„ê¸° ëª…ë ¹ì„ ìº¡ìŠí™”**.

    4.	RemoteControl (Invoker): **ëª…ë ¹ì„ ì‹¤í–‰í•˜ëŠ” í˜¸ì¶œì**.

  **âœ… ëª…ë ¹ íŒ¨í„´ì˜ ì¥ì **

  âœ” **í˜¸ì¶œì(Invoker)ì™€ ìˆ˜ì‹ ì(Receiver) ê°„ì˜ ê²°í•©ë„ë¥¼ ë‚®ì¶¤** â†’ ìœ ì—°í•œ ì„¤ê³„ ê°€ëŠ¥

  âœ” **ìƒˆë¡œìš´ ëª…ë ¹ì„ ì‰½ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆìŒ** (ì˜ˆ: ë³¼ë¥¨ ì¡°ì ˆ ëª…ë ¹ ì¶”ê°€)

  âœ” **ëª…ë ¹ì„ íì— ì €ì¥í•˜ì—¬ ì‹¤í–‰ ì·¨ì†Œ(Undo) ê¸°ëŠ¥ êµ¬í˜„ ê°€ëŠ¥**

  **âœ… ì‘ìš© ì˜ˆì‹œ**

  â€¢	**GUI ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ì²˜ë¦¬**

  â€¢	**ê²Œì„ì—ì„œ í”Œë ˆì´ì–´ í–‰ë™ì„ ìº¡ìŠí™”í•˜ì—¬ ì‹¤í–‰/ì·¨ì†Œ ê´€ë¦¬**

  â€¢	**ë©€í‹°ìŠ¤ë ˆë”© í™˜ê²½ì—ì„œ ì‘ì—…ì„ íì— ì €ì¥í•˜ê³  ì‹¤í–‰**

  **ğŸ¯ ê²°ë¡ **

  â€¢	**ëª…ë ¹ íŒ¨í„´(Command Pattern)**ì€ **í˜¸ì¶œìì™€ ìˆ˜ì‹ ìë¥¼ ë¶„ë¦¬**í•˜ì—¬ **ëª…ë ¹ì„ ê°ì²´ë¡œ ìº¡ìŠí™”í•˜ëŠ” íŒ¨í„´**.

  â€¢	InvokerëŠ” Commandë¥¼ ì‹¤í–‰í•˜ì§€ë§Œ **ì‹¤ì œ ë™ì‘ì€ Receiverê°€ ìˆ˜í–‰**.

  â€¢	Pythonì—ì„œëŠ” ABCë¥¼ í™œìš©í•˜ì—¬ ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ê³  í™œìš©í•  ìˆ˜ ìˆìŒ.

  âœ” **ì´ì œ ëª…ë ¹ íŒ¨í„´ì„ í™œìš©í•˜ë©´ ìœ ì—°í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!** ğŸš€

- GPTì˜ ì˜ˆì‹œ (__call__ ì„ ì‚¬ìš©í•˜ì—¬ command.execute()ë¥¼ í˜¸ì¶œí•˜ëŠ” ëŒ€ì‹  command()ë§Œ í˜¸ì¶œí•˜ê²Œ)

  ë„¤, ì´í•´ë©ë‹ˆë‹¤! Pythonì—ì„œëŠ” **ê°ì²´ë¥¼ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ __call__ì„ ì‚¬ìš©**í•˜ë©´ command.execute() ëŒ€ì‹  **command()ë¡œ í˜¸ì¶œ**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ì´ë ‡ê²Œ í•˜ë©´ **ë” ì§ê´€ì ì´ê³  Pythonë‹¤ìš´ ì½”ë“œ ìŠ¤íƒ€ì¼**ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸš€

  **âœ… __call__ì„ í™œìš©í•œ ëª…ë ¹ íŒ¨í„´**

  ì•„ë˜ëŠ” __call__ì„ ì‚¬ìš©í•˜ì—¬ **ë” ê°„ê²°í•˜ê²Œ ë§Œë“  ëª…ë ¹ íŒ¨í„´ êµ¬í˜„**ì…ë‹ˆë‹¤.

    ```python
    # 1. Receiver (ì‹¤ì œ ë™ì‘ì„ ìˆ˜í–‰í•˜ëŠ” ê°ì²´)
    class TV:
        def turn_on(self):
            print("TVë¥¼ ì¼­ë‹ˆë‹¤.")
    
        def turn_off(self):
            print("TVë¥¼ ë•ë‹ˆë‹¤.")
    
    # 2. ConcreteCommand (êµ¬ì²´ì ì¸ ëª…ë ¹) - __call__ ì‚¬ìš©
    class TVOnCommand:
        def __init__(self, tv: TV):
            self.tv = tv
    
        def __call__(self):  # execute() ëŒ€ì‹  __call__
            self.tv.turn_on()
    
    class TVOffCommand:
        def __init__(self, tv: TV):
            self.tv = tv
    
        def __call__(self):  # execute() ëŒ€ì‹  __call__
            self.tv.turn_off()
    
    # 3. Invoker (í˜¸ì¶œì)
    class RemoteControl:
        def __init__(self):
            self.command = None  # ì‹¤í–‰í•  ëª…ë ¹ ì €ì¥
    
        def set_command(self, command):
            self.command = command  # command ê°ì²´ ì €ì¥
    
        def press_button(self):
            if self.command:
                self.command()  # execute() ëŒ€ì‹  ê·¸ëƒ¥ í˜¸ì¶œ!
    
    # ì‹¤í–‰ í…ŒìŠ¤íŠ¸
    tv = TV()
    remote = RemoteControl()
    
    # TV ì¼œê¸° ëª…ë ¹ì„ ì„¤ì •í•˜ê³  ì‹¤í–‰
    on_command = TVOnCommand(tv)
    remote.set_command(on_command)
    remote.press_button()  # TVë¥¼ ì¼­ë‹ˆë‹¤.
    
    # TV ë„ê¸° ëª…ë ¹ì„ ì„¤ì •í•˜ê³  ì‹¤í–‰
    off_command = TVOffCommand(tv)
    remote.set_command(off_command)
    remote.press_button()  # TVë¥¼ ë•ë‹ˆë‹¤.
    ```

  **âœ… ğŸš€ __call__ì„ ì‚¬ìš©í•œ ì¥ì **

  | **ê¸°ì¡´ ë°©ì‹ (**execute()**)** | __call__ **ì‚¬ìš© ë°©ì‹** |
      | --- | --- |
  | command.execute() í˜¸ì¶œ í•„ìš” | command()ë¡œ ë°”ë¡œ ì‹¤í–‰ ê°€ëŠ¥ |
  | ë©”ì„œë“œ ì´ë¦„(execute)ì´ í•„ìš”í•¨ | í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œ ê°€ëŠ¥ (command()) |
  | executeë¥¼ Invokerê°€ ì•Œì•„ì•¼ í•¨ | ê·¸ëƒ¥ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œí•˜ë©´ ë¨ |

  âœ” **ë” Pythonicí•œ ìŠ¤íƒ€ì¼**

  âœ” **ë©”ì„œë“œ í˜¸ì¶œ ì—†ì´ í•¨ìˆ˜ì²˜ëŸ¼ ì§ê´€ì ì¸ ì‚¬ìš© ê°€ëŠ¥**

  âœ” **ì½”ë“œê°€ ë” ê°„ê²°í•˜ê³  ê¹”ë”í•´ì§**

  **ğŸ¯ ê²°ë¡ **

  Pythonì—ì„œëŠ” __call__ì„ í™œìš©í•˜ë©´ ëª…ë ¹ íŒ¨í„´ì—ì„œ command.execute() ëŒ€ì‹  **command() í˜•íƒœë¡œ ë” ê°„ê²°í•œ í˜¸ì¶œ ë°©ì‹**ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ì´ ë°©ì‹ì´ **Pythonì˜ ì¼ê¸‰ í•¨ìˆ˜(First-Class Function) ê°œë…ê³¼ ì˜ ë§ì•„ë–¨ì–´ì§€ëŠ” ìŠ¤íƒ€ì¼**ì´ë¯€ë¡œ, Pythonì—ì„œëŠ” ë” ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€

- ì±…ì˜ ì˜ˆì‹œ

    ```python
    # strategy_param.py
    # Strategy pattern -- parametrized with closure
    
    """
        >>> joe = Customer('John Doe', 0)
        >>> ann = Customer('Ann Smith', 1100)
        >>> cart = [LineItem('banana', 4, .5),
        ...         LineItem('apple', 10, 1.5),
        ...         LineItem('watermelon', 5, 5.0)]
        >>> Order(joe, cart, fidelity_promo(10))
        <Order total: 42.00 due: 42.00>
        >>> Order(ann, cart, fidelity_promo(10))
        <Order total: 42.00 due: 37.80>
        >>> banana_cart = [LineItem('banana', 30, .5),
        ...                LineItem('apple', 10, 1.5)]
        >>> Order(joe, banana_cart, bulk_item_promo(10))
        <Order total: 30.00 due: 28.50>
        >>> long_cart = [LineItem(str(item_code), 1, 1.0)
        ...               for item_code in range(10)]
        >>> Order(joe, long_cart, LargeOrderPromo(7))
        <Order total: 10.00 due: 9.30>
        >>> Order(joe, cart, LargeOrderPromo(7))
        <Order total: 42.00 due: 42.00>
    
    Using ``partial`` to build a parametrized discounter on the fly::
    
        >>> from functools import partial
        >>> Order(joe, cart, partial(general_discount, 5))
        <Order total: 42.00 due: 39.90>
    
    """
    
    import typing
    from typing import Sequence, Optional, Callable
    
    class Customer(typing.NamedTuple):
        name: str
        fidelity: int
    
    class LineItem:
        def __init__(self, product: str, quantity: int, price: float):
            self.product = product
            self.quantity = quantity
            self.price = price
    
        def total(self):
            return self.price * self.quantity
    
    class Order:  # the Context
        def __init__(
            self,
            customer: Customer,
            cart: Sequence[LineItem],
            promotion: Optional['Promotion'] = None,
        ):
            self.customer = customer
            self.cart = list(cart)
            self.promotion = promotion
    
        def total(self) -> float:
            if not hasattr(self, '__total'):
                self.__total = sum(item.total() for item in self.cart)
            return self.__total
    
        def due(self) -> float:
            if self.promotion is None:
                discount = 0.0
            else:
                discount = self.promotion(self)  # <1>
            return self.total() - discount
    
        def __repr__(self):
            return f'<Order total: {self.total():.2f} due: {self.due():.2f}>'
    
    # tag::STRATEGY_PARAM[]
    
    Promotion = Callable[[Order], float]  # <2>
    
    def fidelity_promo(percent: float) -> Promotion:
        """discount for customers with 1000 or more fidelity points"""
        return lambda order: (
            order.total() * percent / 100 if order.customer.fidelity >= 1000 else 0
        )
    
    def bulk_item_promo(percent: float) -> Promotion:
        """discount for each LineItem with 20 or more units"""
    
        def discounter(order: Order) -> float:
            discount = 0
            for item in order.cart:
                if item.quantity >= 20:
                    discount += item.total() * percent / 100
            return discount
    
        return discounter
    
    class LargeOrderPromo:
        """discount for orders with 10 or more distinct items"""
    
        def __init__(self, percent: float):
            self.percent = percent
    
        def __call__(self, order: Order) -> float:
            distinct_items = {item.product for item in order.cart}
            if len(distinct_items) >= 10:
                return order.total() * self.percent / 100
            return 0
    
    def general_discount(percent: float, order: Order) -> float:
        """unrestricted discount; usage: ``partial(general_discount, 5)``"""
        return order.total() * percent / 100
    
    # end::STRATEGY[]
    ```


### ìš”ì•½

íŒŒì´ì¬ì˜ ë™ì  íŠ¹ì„±ì„ ì˜ ì´ìš©í•´ì„œ ë””ìì¸ íŒ¨í„´ì„ ë” ê¹”ë”íˆ ì ìš©í•  ìˆ˜ ìˆë‹¤.